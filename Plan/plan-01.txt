1) История возникновения
	- середина 90х - бытовая техника, приставки, каждая фирма - свой микроконтроллер и пр.
	- появилась нужда в унификации, в единой платформе, чтобы прогеры не учили каждый микроконтроллер, а можно было всем писать на одном языке
2) Программно-аппаратная архитектура
	- так как-же проц выполняет проги? На самом деле, каждый процессор понимает только т.н. машинные команды, последовательность которых - маш. код. Каждая команда или инструкция - приказ выполнить элементарное действие. В принципе, это все, что надо для программирования - составить прогу в маш коде. Но так было только на заре. Слишком утомительно - строить дом из миллиметровых кирпичиков! Кроме того, у каждого проца, контроллера - свой набор маш команд

	- Показать цикл загрузки компьютера

	- так как-же решить проблему с маш кодом? 1 Революция - языки ассемблера! для каждого числа (маш команды) придумали мнемонику. 93 - INC. Но проблемы остались - все также элементарно.  Это - низкоуровневые языки. Показать разные ассемблеры.
	
	(Может быть, про революции и этапы рассказать тогда, когда будет ООП)
	- 2 революция - появление ЯВУ. Яркий представитель - Фортран. Процедурные языки.Огромный скачок 
		подреволюция - структурное прогр-е. С, Pascal. Недостатки 
	- 3 революция - появление ОО языков. Simula, Smalltalk, C++, Delphi. Недостатки 
	- 4 революция - управляемые ОО языки. 

3) Трансляция
	- так как-же прога на Java превращается в машинный код? есть два пути
		- компиляция. - создание эквивалентной проги в маш коде. + скорость, - непереностимость (разные проци и разные ОС) компилятор привязывает EXE и к процу и к ОС. (показать - формат файлов PE). Компиляторы умеют оптимизировать глубоко, применяя хитрые алгоритмы оптимизации.

		- интерпретация - прога передается в исходных кодах, а у пользователя - стоит интерпретатор. Главный + - можно достичь кроссплатформенности. Главный минус - быстродействие. Кроме того, видно исходники 

		- а можно-ли совместить кросплатформенность и скорость? Можно - JIT компиляция. передавать исходный код, но перед запуском компилируется в машинный код и выполняется процом. Раньше таким был JavaScript. Но потом скорости стало не хватать и для JavaScript сделали JIT компиляцию. Минусы - тормоз перед стартом на компиляцию и из-за ограниченности времени не можем делать оптимизацию. Путь улучшения - кешировать откомпилированные куски JS для каждой страницы и потом проверять, изменился-ли исходный JS для закешированного куска. 

		- Но все равно остаются проблемы. Во первых, прога остается в виде исходного кода - его размеры. А так, как первоначально Java пердполагалось использовать в микроконтроллерах бытовых приборов, то в их маленькой памяти было невозможно разместить JIT компилятор. Выход - отдавать пользователю не исходный код, как при интерпретации и не готовый машинный код, как при компиляции, а исходный код, преобразованный в так называемый байт-код - как-бы машинный код но не для реального процессора, а для выдуманного виртуального процессора. А на машине пользователя байт-код выполняется так называемой JRE - как-бы виртуальный процессор и даже ОС - виртуальная машина Java или JVM.

		- современные JVM очень сложные - начинают сразу интерпретировать, чтобы не было задержки на предварительную компиляцию, а параллельно JIT компилятор компилирует и затем откомпилированные куски вставляет вместо интерпретируемых. Может осуществлять профилирование и повторную глубокую компиляцию каких-то кусков

4)	Для приставок и бытовых дело не пошло, но стало развиваться направление	использования Java для серверных приложений. Со временем JRE стала слишком огромной и оказалось, что в маленькие компы она не лезет, разделили Java SE, Java ME (micro ) и Java EE (SE + доп библиотеки). 
	- Развитие Java сейчас - мобильные платформы или серверные приложения. Десктоп - не часто.

5)  Так в чем-же преимущество байт-кода - зачем такая сложность? Дело в том, что основная трата времени при компиляции - это синтаксический разбор кода на ЯВУ. И это время уже потрачено на машине разраба. Получается, время компиляции разбито на два куска, большая сать которого  - на машине разработчика. А проблема переносимости решается тем, что байт-код предназначен для JRE? которая для всех хост-ОС одинаковая. 


